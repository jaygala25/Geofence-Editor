{"version":3,"sources":["MapComponent.js","index.js"],"names":["libraries","containerStyle","width","height","center","lat","lng","MapComponent","_useState","useState","_useState2","_slicedToArray","setMap","_useState3","_useState4","polygons","setPolygons","_useState5","_useState6","isDrawing","setIsDrawing","_useState7","_useState8","selectedPolygon","setSelectedPolygon","_useState9","_useState10","mousePosition","setMousePosition","_useState11","_useState12","currentPath","setCurrentPath","polygonRefs","useRef","listenersRefs","useEffect","handleEscKey","event","key","document","addEventListener","removeEventListener","onMapLoad","useCallback","map","savePolygonsToStorage","polygonsToSave","polygonsForStorage","polygon","_objectSpread","editable","polygonsData","JSON","stringify","localStorage","setItem","console","log","error","handleMouseMove","e","latLng","handleMapClick","newPoint","prev","concat","_toConsumableArray","onEdit","id","current","nextPath","getPath","getArray","currentPolygons","path","onLoad","addListener","onUnmount","forEach","listener","remove","onOverlayComplete","type","overlay","newPolygon","Date","now","updatedPolygons","savedPolygons","getItem","parse","React","createElement","style","padding","backgroundColor","boxShadow","onClick","marginRight","color","border","borderRadius","cursor","position","top","left","zIndex","onChange","_e$target$value$split","target","value","split","_e$target$value$split2","action","setTimeout","p","toggleEdit","filter","deletePolygon","minWidth","index","label","LoadScript","googleMapsApiKey","GoogleMap","mapContainerStyle","zoom","onMouseMove","DrawingManager","options","drawingMode","drawingControl","polygonOptions","fillColor","fillOpacity","strokeWeight","strokeColor","length","Polyline","strokeOpacity","Polygon","draggable","onMouseUp","onDragEnd","App","rootElement","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.9d67a15f.chunk.js","sourcesContent":["import React, { useState, useRef, useCallback, useEffect } from \"react\";\nimport {\n  LoadScript,\n  GoogleMap,\n  Polygon,\n  DrawingManager,\n  Polyline,\n} from \"@react-google-maps/api\";\n\nconst libraries = [\"drawing\", \"places\"];\n\nconst containerStyle = {\n  width: \"100%\",\n  height: \"100vh\",\n};\n\nconst center = {\n  lat: 52.52047739093263,\n  lng: 13.36653284549709,\n};\n\nconst MapComponent = () => {\n  const [map, setMap] = useState(null);\n  const [polygons, setPolygons] = useState([]);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [selectedPolygon, setSelectedPolygon] = useState(null);\n  const [mousePosition, setMousePosition] = useState(null);\n  const [currentPath, setCurrentPath] = useState([]);\n\n  const polygonRefs = useRef({});\n  const listenersRefs = useRef({});\n\n  useEffect(() => {\n    const handleEscKey = (event) => {\n      if (event.key === \"Escape\" && isDrawing) {\n        setIsDrawing(false);\n        setCurrentPath([]);\n        setMousePosition(null);\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleEscKey);\n    return () => {\n      document.removeEventListener(\"keydown\", handleEscKey);\n    };\n  }, [isDrawing]);\n\n  const onMapLoad = useCallback((map) => {\n    setMap(map);\n  }, []);\n\n  const generateId = () => `polygon_${Date.now()}`;\n\n  const savePolygonsToStorage = (polygonsToSave) => {\n    try {\n      const polygonsForStorage = polygonsToSave.map((polygon) => ({\n        ...polygon,\n        editable: false,\n      }));\n      const polygonsData = JSON.stringify(polygonsForStorage);\n      localStorage.setItem(\"savedPolygons\", polygonsData);\n      console.log(\"Polygons saved successfully\");\n    } catch (error) {\n      console.error(\"Error saving polygons:\", error);\n    }\n  };\n\n  const handleMouseMove = useCallback(\n    (e) => {\n      if (isDrawing) {\n        setMousePosition({\n          lat: e.latLng.lat(),\n          lng: e.latLng.lng(),\n        });\n      }\n    },\n    [isDrawing]\n  );\n\n  const handleMapClick = useCallback(\n    (e) => {\n      if (isDrawing) {\n        const newPoint = {\n          lat: e.latLng.lat(),\n          lng: e.latLng.lng(),\n        };\n        setCurrentPath((prev) => [...prev, newPoint]);\n      }\n    },\n    [isDrawing]\n  );\n\n  const onEdit = useCallback((id) => {\n    if (polygonRefs.current[id]) {\n      const nextPath = polygonRefs.current[id]\n        .getPath()\n        .getArray()\n        .map((latLng) => ({\n          lat: latLng.lat(),\n          lng: latLng.lng(),\n        }));\n\n      setPolygons((currentPolygons) => {\n        const newPolygons = currentPolygons.map((polygon) =>\n          polygon.id === id ? { ...polygon, path: nextPath } : polygon\n        );\n        return newPolygons;\n      });\n    }\n  }, []);\n\n  const onLoad = useCallback(\n    (polygon, id) => {\n      if (polygon) {\n        polygonRefs.current[id] = polygon;\n        const path = polygon.getPath();\n\n        listenersRefs.current[id] = [\n          path.addListener(\"set_at\", () => onEdit(id)),\n          path.addListener(\"insert_at\", () => onEdit(id)),\n          path.addListener(\"remove_at\", () => onEdit(id)),\n        ];\n      }\n    },\n    [onEdit]\n  );\n\n  const onUnmount = useCallback((id) => {\n    if (listenersRefs.current[id]) {\n      listenersRefs.current[id].forEach((listener) => {\n        if (listener) {\n          listener.remove();\n        }\n      });\n      delete polygonRefs.current[id];\n      delete listenersRefs.current[id];\n    }\n  }, []);\n\n  const onOverlayComplete = useCallback((e) => {\n    if (e.type === \"polygon\") {\n      const path = e.overlay\n        .getPath()\n        .getArray()\n        .map((latLng) => ({\n          lat: latLng.lat(),\n          lng: latLng.lng(),\n        }));\n\n      const newPolygon = {\n        id: generateId(),\n        path,\n        editable: false,\n      };\n\n      setPolygons((current) => {\n        const updatedPolygons = [...current, newPolygon];\n        savePolygonsToStorage(updatedPolygons);\n        return updatedPolygons;\n      });\n\n      e.overlay.setMap(null);\n      setIsDrawing(false);\n      setCurrentPath([]);\n      setMousePosition(null);\n    }\n  }, []);\n\n  const toggleDrawing = () => {\n    setIsDrawing(!isDrawing);\n    if (!isDrawing) {\n      setPolygons((current) =>\n        current.map((polygon) => ({ ...polygon, editable: false }))\n      );\n      setSelectedPolygon(null);\n      setCurrentPath([]);\n      setMousePosition(null);\n    } else {\n      setCurrentPath([]);\n      setMousePosition(null);\n    }\n  };\n\n  const toggleEdit = (id) => {\n    setPolygons((current) => {\n      const newPolygons = current.map((polygon) => {\n        if (polygon.id === id && polygon.editable) {\n          setTimeout(() => {\n            const polygonsToSave = current.map((p) => ({\n              ...p,\n              editable: false,\n            }));\n            savePolygonsToStorage(polygonsToSave);\n          }, 0);\n        }\n        return {\n          ...polygon,\n          editable: polygon.id === id ? !polygon.editable : false,\n        };\n      });\n      return newPolygons;\n    });\n    setSelectedPolygon(id);\n  };\n\n  const deletePolygon = (id) => {\n    setPolygons((current) => {\n      const updatedPolygons = current.filter((polygon) => polygon.id !== id);\n      savePolygonsToStorage(updatedPolygons);\n      return updatedPolygons;\n    });\n    onUnmount(id);\n    if (selectedPolygon === id) {\n      setSelectedPolygon(null);\n    }\n  };\n\n  useEffect(() => {\n    const savedPolygons = localStorage.getItem(\"savedPolygons\");\n    if (savedPolygons) {\n      try {\n        setPolygons(JSON.parse(savedPolygons));\n      } catch (error) {\n        console.error(\"Error loading saved polygons:\", error);\n      }\n    }\n  }, []);\n\n  return (\n    <div style={{ height: \"100vh\", width: \"100%\" }}>\n      <div\n        style={{\n          padding: \"10px\",\n          backgroundColor: \"#fff\",\n          boxShadow: \"0 2px 4px rgba(0,0,0,0.1)\",\n        }}\n      >\n        <button\n          onClick={toggleDrawing}\n          style={{\n            marginRight: \"10px\",\n            padding: \"8px 16px\",\n            backgroundColor: isDrawing ? \"#ff4444\" : \"#4CAF50\",\n            color: \"white\",\n            border: \"none\",\n            borderRadius: \"4px\",\n            cursor: \"pointer\",\n          }}\n        >\n          {isDrawing ? \"Cancel Drawing\" : \"New Polygon\"}\n        </button>\n      </div>\n\n      <div\n        style={{\n          position: \"absolute\",\n          top: \"70px\",\n          left: \"10px\",\n          zIndex: 1,\n          backgroundColor: \"#fff\",\n          padding: \"10px\",\n          borderRadius: \"4px\",\n          boxShadow: \"0 2px 4px rgba(0,0,0,0.1)\",\n        }}\n      >\n        <select\n          onChange={(e) => {\n            const [action, id] = e.target.value.split(\"|\");\n            if (action === \"edit\") toggleEdit(id);\n            if (action === \"delete\") deletePolygon(id);\n            e.target.value = \"\";\n          }}\n          value=\"\"\n          style={{\n            padding: \"8px\",\n            borderRadius: \"4px\",\n            border: \"1px solid #ccc\",\n            backgroundColor: \"#fff\",\n            cursor: \"pointer\",\n            minWidth: \"150px\",\n          }}\n        >\n          <option value=\"\">Select Polygon</option>\n          {polygons.map((polygon, index) => (\n            <optgroup key={polygon.id} label={`Polygon ${index + 1}`}>\n              <option value={`edit|${polygon.id}`}>\n                {polygon.editable ? \"Done Editing\" : \"Edit\"}\n              </option>\n              <option value={`delete|${polygon.id}`}>Delete</option>\n            </optgroup>\n          ))}\n        </select>\n      </div>\n\n      <LoadScript googleMapsApiKey=\"\" libraries={libraries}>\n        <GoogleMap\n          mapContainerStyle={containerStyle}\n          center={center}\n          zoom={12}\n          onLoad={onMapLoad}\n          onMouseMove={handleMouseMove}\n          onClick={handleMapClick}\n        >\n          {isDrawing && (\n            <DrawingManager\n              onOverlayComplete={onOverlayComplete}\n              options={{\n                drawingMode: \"polygon\",\n                drawingControl: false,\n                polygonOptions: {\n                  fillColor: \"#FF0000\",\n                  fillOpacity: 0.2,\n                  strokeWeight: 2,\n                  strokeColor: \"#FF0000\",\n                  editable: true,\n                },\n              }}\n            />\n          )}\n\n          {isDrawing && currentPath.length > 0 && mousePosition && (\n            <Polyline\n              path={[currentPath[currentPath.length - 1], mousePosition]}\n              options={{\n                strokeColor: \"#FFFFFF\",\n                strokeWeight: 2,\n                strokeOpacity: 1,\n              }}\n            />\n          )}\n\n          {isDrawing && currentPath.length > 1 && (\n            <Polyline\n              path={currentPath}\n              options={{\n                strokeColor: \"#FF0000\",\n                strokeWeight: 2,\n                strokeOpacity: 1,\n              }}\n            />\n          )}\n\n          {polygons.map((polygon) => (\n            <Polygon\n              key={polygon.id}\n              path={polygon.path}\n              editable={polygon.editable}\n              draggable={polygon.editable}\n              onMouseUp={() => polygon.editable && onEdit(polygon.id)}\n              onDragEnd={() => onEdit(polygon.id)}\n              onLoad={(p) => onLoad(p, polygon.id)}\n              onUnmount={() => onUnmount(polygon.id)}\n              options={{\n                fillColor: polygon.editable ? \"#00FF00\" : \"#FF0000\",\n                fillOpacity: 0.2,\n                strokeWeight: 2,\n                strokeColor: polygon.editable ? \"#00FF00\" : \"#FF0000\",\n              }}\n            />\n          ))}\n        </GoogleMap>\n      </LoadScript>\n    </div>\n  );\n};\n\nexport default MapComponent;\n","import React, { useState, useRef, useCallback } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { LoadScript, GoogleMap, Polygon } from \"@react-google-maps/api\";\nimport MapComponent from \"./MapComponent\";\nimport \"./styles.css\";\n\n// This example presents a way to handle editing a Polygon\n// The objective is to get the new path on every editing event :\n// - on dragging the whole Polygon\n// - on moving one of the existing points (vertex)\n// - on adding a new point by dragging an edge point (midway between two vertices)\n\n// We achieve it by defining refs for the google maps API Polygon instances and listeners with `useRef`\n// Then we bind those refs to the currents instances with the help of `onLoad`\n// Then we get the new path value with the `onEdit` `useCallback` and pass it to `setPath`\n// Finally we clean up the refs with `onUnmount`\n\nfunction App() {\n  return <MapComponent />;\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}